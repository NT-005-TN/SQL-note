# Полезные сайты:
## https://www.sqlstyle.guide/ru/ - здесь можно отформатировать запрос в наиболее удобном виде
##  https://codebeautify.org/sqlformatter - здесь реководство по стилю SQL

1. [Полезные сайты](#полезные-сайты)
2. [Основы SQL](#основы-sql)

   * [Диалекты SQL](#диалекты-sql)
   * [Общее для всех диалектов](#общее-для-всех-диалектов)

     * [Операторы SELECT](#операторы-select)
     * [Логические операторы](#логические-операторы)
     * [Агрегатные функции](#агрегатные-функции)
     * [Группировка](#группировка)
     * [Объединения](#объединения)
     * [Подзапросы](#подзапросы)
     * [Операции с множествами](#операции-с-множествами)
     * [Отличия и особенности диалектов](#отличия-и-особенности-диалектов)
3. [SQLite](#sqlite)

   * [Разбор кода](#разбор-кода)
   * [Операции с множествами (SQLite)](#операции-с-множествами-sqlite)
4. [PostgreSQL](#postgresql)

   * [Отличия от SQLite](#отличия-от-sqlite)
5. [OracleSQL](#oraclesql)

   * [Отличия от других диалектов](#отличия-от-других-диалектов)



# Основы SQL

## Какие рассматриваются диалекты SQL: 
  SQLite 
  
  OracleSQL
  
  PostgrseSQL

Впоследствии будет использоваться один запрос для всех диалектов, где будут видны отличия между ними

Для каждого диалекта есть по 2 файла:

  С основным запросом
  
  С операциями с множествами

## Общее для всех

### Операторы SELECT
#### SELECT ... FROM ...
  
Это основной оператор извлечения данных из таблицы.

SELECT указывает, какие столбцы (или выражения) нужно получить.

FROM указывает, из какой таблицы или источника берутся данные.


#### DISTINCT

Модификатор к SELECT, удаляющий дубликаты строк из результата.

Используется, когда нужно получить только уникальные записи.


#### WHERE

Фильтрует строки, которые попадают в результат.

Указывает логическое условие (или несколько), которому должны удовлетворять строки.

Применяется до группировки и сортировки.


#### ORDER BY

Определяет порядок, в котором возвращаются строки.

Можно сортировать по одному или нескольким столбцам.

По умолчанию сортировка по возрастанию, можно указать убывание.


#### LIMIT

Ограничивает количество строк, возвращаемых в результате.

Используется для выборки «первых N строк».

Поддерживается во многих СУБД, но в Oracle заменяется на FETCH FIRST n ROWS ONLY.


#### OFFSET

Пропускает указанное количество строк перед тем, как начать вывод результата.

Удобно для постраничной выборки.

В Oracle используется в составе конструкции OFFSET ... ROWS FETCH NEXT ... ROWS ONLY

### Логические операторы
#### AND, OR, NOT
  
Это логические операторы, применяемые в условиях (например, в WHERE):

AND — истинно, если оба условия верны.

OR — истинно, если хотя бы одно из условий верно.

NOT — инвертирует условие: если условие истинно, результат будет ложным, и наоборот.


#### IS NULL, IS NOT NULL

Применяются для проверки на отсутствие значения в ячейке:

IS NULL — возвращает истину, если значение отсутствует (NULL).

IS NOT NULL — возвращает истину, если значение присутствует (не NULL).


#### IN, NOT IN

Используются для проверки, содержится ли значение в наборе:

IN — возвращает истину, если значение входит в указанный список.

NOT IN — возвращает истину, если значение не входит в список.


#### BETWEEN, NOT BETWEEN

Применяются для проверки, находится ли значение в пределах диапазона:

BETWEEN — истина, если значение находится включительно между двумя границами.

NOT BETWEEN — истина, если значение вне диапазона.


#### LIKE, NOT LIKE

Используются для поиска по шаблону строк с использованием подстановочных символов:

LIKE — истина, если строка соответствует шаблону.

NOT LIKE — истина, если строка не соответствует шаблону.

### Агрегатные функции
#### COUNT()
Возвращает количество строк в выборке.

Может учитывать все строки (включая NULL) или только те, в которых указано значение (если применяется к конкретному столбцу).


#### SUM()
Вычисляет сумму всех значений числового столбца.

Применяется только к числовым типам данных. Игнорирует значения NULL.


#### AVG()
Вычисляет среднее арифметическое значение числового столбца.

Учитываются только ненулевые значения (NULL игнорируется).


#### MIN()
Определяет наименьшее (минимальное) значение в столбце.

Работает с числовыми, строковыми, датами и другими сравнимыми типами.


#### MAX()
Определяет наибольшее (максимальное) значение в столбце.

Также поддерживает различные типы данных, включая строки и даты.


### Группировка
#### GROUP BY
Используется для группировки строк в таблице по значениям одного или нескольких столбцов.

После группировки можно применять агрегатные функции (например, COUNT(), SUM(), AVG() и т. д.) к каждой группе.

Все столбцы, указанные в SELECT, должны быть либо в GROUP BY, либо агрегатными функциями.


#### HAVING
Используется для фильтрации сгруппированных данных (в отличие от WHERE, который фильтрует строки до группировки).

Применяется только после GROUP BY.

Обычно содержит условия, основанные на агрегатных функциях (например, HAVING COUNT(*) > 1).

Позволяет исключить группы, не соответствующие условиям.

### Объединения
#### INNER JOIN
Выбирает только те строки, где в обеих таблицах есть совпадение по условию соединения.

Если нет совпадения — строка не попадает в результат.


#### LEFT JOIN (или LEFT OUTER JOIN)
Возвращает все строки из левой таблицы (той, что указана первой), даже если в правой таблице нет соответствий.

Если соответствия нет — в полях правой таблицы будет NULL.

#### RIGHT JOIN (или RIGHT OUTER JOIN)
Аналогично LEFT JOIN, но наоборот:

возвращает все строки из правой таблицы, даже если в левой нет соответствий.

Если соответствия нет — поля из левой таблицы будут NULL.

SQLite не поддерживает напрямую.


#### FULL JOIN (или FULL OUTER JOIN)
Возвращает все строки из обеих таблиц — как с совпадениями, так и без.

Если нет совпадения в одной из таблиц — соответствующие поля будут NULL.

SQLite не поддерживает напрямую.

### Подзапросы
  Внутри SELECT, FROM, WHERE, EXISTS, IN

### Операции с множествами
#### UNION
Объединяет результаты двух SELECT-запросов.

Удаляет дубликаты — в итоговом результате каждая строка будет уникальной.


#### UNION ALL
Также объединяет результаты двух SELECT-запросов.

Не удаляет дубликаты, возвращает все строки из обоих запросов.


#### INTERSECT
Возвращает только те строки, которые присутствуют в обоих запросах.

Автоматически удаляет дубликаты.


#### EXCEPT
Возвращает строки, которые есть в первом запросе, но отсутствуют во втором.

Удаляет дубликаты.

В Oracle используется аналог — оператор MINUS, который выполняет ту же функцию.


### Отличия и особенности в общем
  SQLite — минималистичная: не поддерживает типизацию, RIGHT JOIN, FULL JOIN, индексы на выражениях, оконные функции в ранних версиях.
  
  PostgreSQL — почти полная реализация SQL: поддержка оконных функций, CTE, JSON, RETURNING.
  
  Oracle SQL — имеет нестандартные элементы (DUAL, ROWNUM, MINUS, PL/SQL), но всё базовое поддерживается.

# SQLite
Рассмотрим следующие файлы:

  https://github.com/NT-005-TN/SQL-note/blob/main/SQLiteFile_1.sql
  
  https://github.com/NT-005-TN/SQL-note/blob/main/SQLiteFile_2.sql

## Разбор кода

#### WITH employees AS (...)
WITH — это конструкция CTE (Common Table Expression), позволяющая определить временные таблицы. Она делает код читаемее и позволяет использовать именованные подзапросы многократно.

employees AS (...) — создаёт временную таблицу employees, содержащую 5 строк. Каждая строка задаётся через SELECT, объединённый через UNION ALL.

#### SELECT 1 AS id, 'Alice' AS name, ...
SELECT — оператор выбора данных. Он формирует строку с заданными значениями.

AS — задаёт псевдонимы (алиасы) для столбцов. Например, 1 AS id означает, что числу 1 присваивается имя id — этот столбец будет так называться в результирующей таблице.

#### UNION ALL
Объединяет строки из нескольких SELECT, не удаляя дубликаты (в отличие от UNION). Используется для создания множества строк в CTE employees.

#### departments AS (...)
Создаёт временную таблицу с информацией об отделах. Содержит два столбца: dept (название отдела) и location (город). Также использует UNION ALL для объединения строк.

#### avg_salary AS (...)
Создаёт таблицу со средней зарплатой в каждом отделе. Использует агрегатную функцию AVG() и группировку по dept.

AVG(salary) — вычисляет среднюю зарплату по каждой группе (отделу). Это агрегатная функция, применяемая после группировки.

GROUP BY dept — группирует строки по значению в dept, чтобы к каждой группе можно было применить агрегатную функцию (AVG в данном случае).

### Основной запрос
#### SELECT DISTINCT ...
SELECT — основной оператор извлечения данных. Определяет, какие поля должны быть в результате.

DISTINCT — убирает дубликаты из результатов. То есть, если несколько строк имеют одинаковые значения всех указанных полей — останется только одна.

#### e.name, e.salary, e.bonus, d.location
Выбираются конкретные поля из таблиц employees (псевдоним e) и departments (псевдоним d). Эти поля будут видны в итоговой таблице.

#### Подзапрос в SELECT:
(SELECT COUNT(*) FROM employees WHERE salary > e.salary) AS higher_paid

Этот подзапрос считает, сколько сотрудников имеют зарплату выше текущей строки e.salary.

COUNT(*) — агрегатная функция, которая возвращает количество строк, удовлетворяющих условию.

WHERE salary > e.salary — условие фильтрации: выбраны только те строки, где зарплата выше текущей.

#### CASE ... END AS bonus_category
CASE — это условная логика (аналог if...else), которая выбирает одно из значений в зависимости от условий.

Если bonus IS NULL, то выводится 'No Bonus'

Если bonus BETWEEN 1 AND 5000, то 'Small Bonus'

Во всех остальных случаях — 'Big Bonus'

#### FROM employees e
FROM — указывает таблицу, из которой выбираются строки. Здесь — временная таблица employees.

e — псевдоним (alias), позволяет обращаться к полям как e.name, e.salary.

#### INNER JOIN departments d ON e.dept = d.dept
INNER JOIN — соединяет две таблицы по совпадению значений. Строки попадают в результат, только если совпадают значения в e.dept и d.dept.

ON — определяет условие соединения.

#### LEFT JOIN avg_salary a ON e.dept = a.dept
LEFT JOIN — соединяет таблицы, но в отличие от INNER JOIN, сохраняет все строки из левой таблицы (employees), даже если нет соответствия в avg_salary.

Если в avg_salary нет строки с нужным dept, то a.avg_sal будет NULL.

#### WHERE (...)
WHERE — фильтрует строки по заданным условиям. Применяется после соединений.

Условия:
e.salary BETWEEN 60000 AND 80000

Проверяет, входит ли зарплата в диапазон от 60 000 до 80 000 включительно.

e.dept IN ('HR', 'IT')

Проверяет, находится ли dept в списке значений.

e.name NOT LIKE '%z%'

LIKE '%z%' ищет наличие подстроки 'z' в имени.

NOT LIKE — исключает такие строки.

NOT EXISTS (...)

EXISTS проверяет, есть ли строки, удовлетворяющие подзапросу.

NOT EXISTS — исключает строки, для которых подзапрос возвращает хотя бы одну строку.

Внутренний подзапрос ищет, есть ли в этом же отделе сотрудники с зарплатой > 100 000.

e.bonus IS NOT NULL

Убирает строки с пустым бонусом (NULL).

#### ORDER BY e.salary DESC
ORDER BY — сортирует результат. Здесь — по зарплате, от самой большой к меньшей.

DESC — указывает сортировку по убыванию.

#### LIMIT 3 OFFSET 1
LIMIT — ограничивает количество возвращаемых строк (здесь — максимум 3 строки).

OFFSET — пропускает указанное количество строк (здесь — 1). То есть, результат начнётся со второй строки после сортировки.

### Операции с множествами

#### 1. UNION ALL — объединение без удаления дубликатов

SELECT name FROM employees WHERE dept = 'HR'

UNION ALL

SELECT name FROM employees WHERE dept = 'IT';

#### SELECT name FROM employees
Оператор SELECT извлекает столбец name из таблицы employees.

#### WHERE dept = 'HR' / WHERE dept = 'IT'
Условие фильтрует строки по значению в столбце dept. Первая часть выбирает сотрудников из отдела HR, вторая — из отдела IT.

#### UNION ALL
Объединяет все строки из двух SELECT, включая дубликаты.

Если одно и то же имя встречается в обеих выборках, оно появится дважды.

Этот оператор быстрее, чем обычный UNION, потому что не выполняет сортировку и сравнение.

### 2. INTERSECT — пересечение двух множеств
SELECT name FROM employees WHERE bonus IS NOT NULL

INTERSECT

SELECT name FROM employees WHERE salary > 60000;
#### WHERE bonus IS NOT NULL
Отбирает строки, где поле bonus содержит значение (не NULL).

IS NOT NULL — логическая проверка, исключающая строки без бонуса.

#### WHERE salary > 60000
Отбирает сотрудников с зарплатой выше 60 000.

#### INTERSECT
Возвращает только те строки, которые есть в обеих выборках.

Работает как логическое "и": показывает имена сотрудников, которые одновременно имеют бонус и зарплату выше 60 000.

Удаляет дубликаты и сравнивает строки по значению, не по позиции.

#### 3. EXCEPT — вычитание множеств
SELECT name FROM employees WHERE dept = 'IT'

EXCEPT

SELECT name FROM employees WHERE bonus IS NULL;
#### WHERE dept = 'IT'
Извлекает имена сотрудников из отдела IT.

#### WHERE bonus IS NULL
Находит тех, у кого нет значения в поле bonus.

#### EXCEPT
Возвращает строки, которые есть в первом наборе, но отсутствуют во втором.

В данном случае: всех сотрудников из IT, у которых есть бонус.

Этот оператор также удаляет дубликаты и работает на уровне значений, как UNION.

# PostgrseSQL
Далее будут написаны отличия запроса в PostgrseSQL от SQLite, все что не упомянуто ниже остается таким же как и в SQLite

файлы:

https://github.com/NT-005-TN/SQL-note/blob/main/postgrseSQL_File_1.sql

https://github.com/NT-005-TN/SQL-note/blob/main/postgrseSQL_File_2.sql

#### WITH employees AS (...) — явное указание типа NULL-значений
В PostgreSQL для NULL, особенно в конструкциях с UNION ALL, часто указывают типы, чтобы избежать неоднозначностей:

SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, NULL::int AS bonus

NULL::int — явное указание, что NULL — это целое число (int).

Это важно, чтобы PostgreSQL корректно определил тип столбца в CTE и не выдал ошибку или предупреждение.

#### LIMIT и OFFSET — работают так же, как в SQLite
В PostgreSQL эти конструкции полностью совпадают по смыслу и синтаксису с SQLite.

Можно использовать LIMIT 3 OFFSET 1 без изменений.

#### Типизация и литералы строк
В PostgreSQL строки в SQL-запросах всегда берутся в одинарные кавычки '...'.

Числовые и логические типы строго соблюдаются.

#### Подзапросы и CASE — расширенные возможности
PostgreSQL поддерживает более сложные выражения в CASE, включая вложенные CASE.

В запросе используется стандартный синтаксис — отличий здесь нет.

####  JOIN — поддерживает все типы JOIN (INNER, LEFT, RIGHT, FULL)
В PostgreSQL поддерживаются все виды соединений таблиц, включая RIGHT JOIN и FULL OUTER JOIN.

В примере используются INNER JOIN и LEFT JOIN, которые идентичны SQLite.

#### Работа с NULL — поведение строгое
В PostgreSQL операции с NULL подчиняются стандарту SQL:

NULL не равно ничему, даже самому себе.

Для проверки NULL используется IS NULL и IS NOT NULL.

В коде это используется корректно, никаких изменений не требуется.

####  UNION, INTERSECT, EXCEPT — семантика
Семантика этих операций в PostgreSQL совпадает с SQLite, но в PostgreSQL операции всегда удаляют дубликаты (исключая UNION ALL).

PostgreSQL поддерживает все эти операции и оптимизирован для работы с большими объёмами данных.

####  Пример с типами в CTE (PostgreSQL)
WITH employees AS (

    SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, NULL::int AS bonus UNION ALL
    
    SELECT 2, 'Bob', 'IT', 70000, 5000 UNION ALL
    
    ...
    
)

Явное указание типа NULL помогает избежать ошибок компиляции.

#### Функции агрегации и группировки — расширенные возможности

В PostgreSQL поддерживаются оконные функции, которые можно добавить в запрос, например, ROW_NUMBER() OVER(...).

В запросе это не используется, но при необходимости это легко расширяется.

#### Поддержка подзапросов — полная
Подзапросы в SELECT, WHERE, FROM работают без ограничений.

Подзапросы могут возвращать множество строк или одно значение, поддерживаются коррелированные подзапросы (как в твоём запросе).

#### Псевдонимы и кавычки
Если в PostgreSQL имена столбцов или таблиц содержат заглавные буквы или спецсимволы, их нужно брать в двойные кавычки "ColumnName".

В запросе имена простые и кавычки не нужны.

# OracleSQL
Аналогично прошлой части.

файлы:

https://github.com/NT-005-TN/SQL-note/blob/main/oracleSQL_File_1.sql

https://github.com/NT-005-TN/SQL-note/blob/main/oracleSQL_File_2.sql

#### WITH employees AS (...)
В Oracle SQL:

Для создания строк используется SELECT ... FROM DUAL, так как нельзя писать SELECT ... UNION ALL SELECT ... без указания таблицы.

Таблица DUAL — специальная служебная таблица с одной строкой, используемая для выборок без реальных таблиц.


SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, CAST(NULL AS NUMBER) AS bonus FROM dual

UNION ALL

SELECT 2, 'Bob', 'IT', 70000, 5000 FROM dual

...

Пояснение:

В Oracle каждая часть SELECT должна иметь источник данных, здесь это dual.

CAST(NULL AS NUMBER) — явное указание типа NULL, чтобы избежать ошибок приведения типов.

#### LIMIT и OFFSET

В Oracle SQL нет ключевых слов LIMIT и OFFSET. Вместо них используется конструкция:


OFFSET 1 ROWS FETCH NEXT 3 ROWS ONLY

OFFSET 1 ROWS — пропустить 1 строку.

FETCH NEXT 3 ROWS ONLY — взять следующие 3 строки.

Пояснение:

Это синтаксис стандарта SQL:2008, который Oracle реализует с версии 12c. Работает аналогично LIMIT ... OFFSET ... в других СУБД.

#### Объявление временных таблиц (CTE) с WITH
В Oracle SQL, при использовании CTE:

Каждый SELECT должен иметь FROM dual.

Все строки объединяются с помощью UNION ALL.

#### Типы данных и CAST
Для NULL в числовых столбцах требуется явное приведение типа: CAST(NULL AS NUMBER).

В SQLite это не нужно, так как там динамическая типизация.

#### EXCEPT → MINUS
Oracle не поддерживает оператор EXCEPT, вместо него используется:
  
SELECT name FROM employees WHERE dept = 'IT'

MINUS

SELECT name FROM employees WHERE bonus IS NULL;
  
Пояснение:

MINUS возвращает строки из первого запроса, которых нет во втором — полностью аналогично EXCEPT в других СУБД.

#### Особенности INNER JOIN, LEFT JOIN
В Oracle INNER JOIN и LEFT JOIN работают так же, как и в SQLite, различий нет.

Отличия могут быть в обработке NULL и оптимизации, но для базовых запросов это не критично.

#### Особенности CASE
CASE в Oracle работает идентично стандарту SQL, никаких отличий по синтаксису и логике нет.

#### LIKE и NOT LIKE
Аналогично другим СУБД: % — любой набор символов, _ — один символ.

В Oracle важен регистр символов (по умолчанию поиск чувствителен к регистру). Чтобы сделать нечувствительным, нужно использовать функции, например, UPPER().

#### Сортировка и фильтрация
ORDER BY ... DESC работает как обычно.

Порядок сортировки важен для корректной работы OFFSET FETCH.

#### Кратко по операциям с множествами в Oracle

UNION ALL -	Совпадает -	Объединяет все строки, включая дубликаты.

INTERSECT -	Совпадает -	Возвращает пересечение, уникальные строки.

EXCEPT - Вместо EXCEPT используется MINUS, возвращает строки из первого запроса, отсутствующие во втором.
