# Полезные сайты:
## https://www.sqlstyle.guide/ru/ - здесь можно отформатировать запрос в наиболее удобном виде
##  https://codebeautify.org/sqlformatter - здесь реководство по стилю SQL

# Основы SQL

## Какие рассматриваются диалекты SQL: 
  SQLite 
  
  OracleSQL
  
  PostgrseSQL

Впоследствии будет использоваться один запрос для всех диалектов, где будут видны отличия между ними

Для каждого диалекта есть по 2 файла:
  С основным запросом
  С операциями с множествами

## Общее для всех

### Операторы SELECT
  SELECT ... FROM ...

  DISTINCT

  WHERE

  ORDER BY

  LIMIT (в Oracle используется FETCH FIRST n ROWS ONLY)

  OFFSET (в Oracle — с OFFSET ... FETCH)

### Логические операторы
  AND, OR, NOT
  
  IS NULL, IS NOT NULL
  
  IN, NOT IN
  
  BETWEEN, NOT BETWEEN
  
  LIKE, NOT LIKE

### Агрегатные функции
  COUNT()
  
  SUM()
  
  AVG()
  
  MIN()
  
  MAX()

### Группировка
  GROUP BY
  
  HAVING

### Объединения
  INNER JOIN

  LEFT JOIN
  
  RIGHT JOIN (в SQLite не поддерживается напрямую, но можно обойти)
  
  FULL JOIN (в SQLite — нет поддержки)

### Подзапросы
  Внутри SELECT, FROM, WHERE, EXISTS, IN

### Операции с множествами
  UNION
  
  UNION ALL

  INTERSECT
  
  EXCEPT (в Oracle — MINUS вместо EXCEPT)

### Отличия и особенности в общем
  SQLite — минималистичная: не поддерживает типизацию, RIGHT JOIN, FULL JOIN, индексы на выражениях, оконные функции в ранних версиях.
  
  PostgreSQL — почти полная реализация SQL: поддержка оконных функций, CTE, JSON, RETURNING.
  
  Oracle SQL — имеет нестандартные элементы (DUAL, ROWNUM, MINUS, PL/SQL), но всё базовое поддерживается.

# SQLite
Рассмотрим следующие файлы:
  https://github.com/NT-005-TN/SQL-note/blob/main/SQLiteFile_1.sql
  https://github.com/NT-005-TN/SQL-note/blob/main/SQLiteFile_2.sql

## Разбор кода

#### WITH employees AS (...)
WITH — это конструкция CTE (Common Table Expression), позволяющая определить временные таблицы. Она делает код читаемее и позволяет использовать именованные подзапросы многократно.

employees AS (...) — создаёт временную таблицу employees, содержащую 5 строк. Каждая строка задаётся через SELECT, объединённый через UNION ALL.

#### SELECT 1 AS id, 'Alice' AS name, ...
SELECT — оператор выбора данных. Он формирует строку с заданными значениями.

AS — задаёт псевдонимы (алиасы) для столбцов. Например, 1 AS id означает, что числу 1 присваивается имя id — этот столбец будет так называться в результирующей таблице.

#### UNION ALL
Объединяет строки из нескольких SELECT, не удаляя дубликаты (в отличие от UNION). Используется для создания множества строк в CTE employees.

#### departments AS (...)
Создаёт временную таблицу с информацией об отделах. Содержит два столбца: dept (название отдела) и location (город). Также использует UNION ALL для объединения строк.

#### avg_salary AS (...)
Создаёт таблицу со средней зарплатой в каждом отделе. Использует агрегатную функцию AVG() и группировку по dept.

AVG(salary) — вычисляет среднюю зарплату по каждой группе (отделу). Это агрегатная функция, применяемая после группировки.

GROUP BY dept — группирует строки по значению в dept, чтобы к каждой группе можно было применить агрегатную функцию (AVG в данном случае).

### Основной запрос
#### SELECT DISTINCT ...
SELECT — основной оператор извлечения данных. Определяет, какие поля должны быть в результате.

DISTINCT — убирает дубликаты из результатов. То есть, если несколько строк имеют одинаковые значения всех указанных полей — останется только одна.

#### e.name, e.salary, e.bonus, d.location
Выбираются конкретные поля из таблиц employees (псевдоним e) и departments (псевдоним d). Эти поля будут видны в итоговой таблице.

#### Подзапрос в SELECT:
(SELECT COUNT(*) FROM employees WHERE salary > e.salary) AS higher_paid

Этот подзапрос считает, сколько сотрудников имеют зарплату выше текущей строки e.salary.

COUNT(*) — агрегатная функция, которая возвращает количество строк, удовлетворяющих условию.

WHERE salary > e.salary — условие фильтрации: выбраны только те строки, где зарплата выше текущей.

#### CASE ... END AS bonus_category
CASE — это условная логика (аналог if...else), которая выбирает одно из значений в зависимости от условий.

Если bonus IS NULL, то выводится 'No Bonus'

Если bonus BETWEEN 1 AND 5000, то 'Small Bonus'

Во всех остальных случаях — 'Big Bonus'

#### FROM employees e
FROM — указывает таблицу, из которой выбираются строки. Здесь — временная таблица employees.

e — псевдоним (alias), позволяет обращаться к полям как e.name, e.salary.

#### INNER JOIN departments d ON e.dept = d.dept
INNER JOIN — соединяет две таблицы по совпадению значений. Строки попадают в результат, только если совпадают значения в e.dept и d.dept.

ON — определяет условие соединения.

#### LEFT JOIN avg_salary a ON e.dept = a.dept
LEFT JOIN — соединяет таблицы, но в отличие от INNER JOIN, сохраняет все строки из левой таблицы (employees), даже если нет соответствия в avg_salary.

Если в avg_salary нет строки с нужным dept, то a.avg_sal будет NULL.

#### WHERE (...)
WHERE — фильтрует строки по заданным условиям. Применяется после соединений.

Условия:
e.salary BETWEEN 60000 AND 80000

Проверяет, входит ли зарплата в диапазон от 60 000 до 80 000 включительно.

e.dept IN ('HR', 'IT')

Проверяет, находится ли dept в списке значений.

e.name NOT LIKE '%z%'

LIKE '%z%' ищет наличие подстроки 'z' в имени.

NOT LIKE — исключает такие строки.

NOT EXISTS (...)

EXISTS проверяет, есть ли строки, удовлетворяющие подзапросу.

NOT EXISTS — исключает строки, для которых подзапрос возвращает хотя бы одну строку.

Внутренний подзапрос ищет, есть ли в этом же отделе сотрудники с зарплатой > 100 000.

e.bonus IS NOT NULL

Убирает строки с пустым бонусом (NULL).

#### ORDER BY e.salary DESC
ORDER BY — сортирует результат. Здесь — по зарплате, от самой большой к меньшей.

DESC — указывает сортировку по убыванию.

#### LIMIT 3 OFFSET 1
LIMIT — ограничивает количество возвращаемых строк (здесь — максимум 3 строки).

OFFSET — пропускает указанное количество строк (здесь — 1). То есть, результат начнётся со второй строки после сортировки.

### Операции с множествами

#### 1. UNION ALL — объединение без удаления дубликатов

SELECT name FROM employees WHERE dept = 'HR'

UNION ALL

SELECT name FROM employees WHERE dept = 'IT';

#### SELECT name FROM employees
Оператор SELECT извлекает столбец name из таблицы employees.

#### WHERE dept = 'HR' / WHERE dept = 'IT'
Условие фильтрует строки по значению в столбце dept. Первая часть выбирает сотрудников из отдела HR, вторая — из отдела IT.

#### UNION ALL
Объединяет все строки из двух SELECT, включая дубликаты.

Если одно и то же имя встречается в обеих выборках, оно появится дважды.

Этот оператор быстрее, чем обычный UNION, потому что не выполняет сортировку и сравнение.

### 2. INTERSECT — пересечение двух множеств
SELECT name FROM employees WHERE bonus IS NOT NULL

INTERSECT

SELECT name FROM employees WHERE salary > 60000;
#### WHERE bonus IS NOT NULL
Отбирает строки, где поле bonus содержит значение (не NULL).

IS NOT NULL — логическая проверка, исключающая строки без бонуса.

#### WHERE salary > 60000
Отбирает сотрудников с зарплатой выше 60 000.

#### INTERSECT
Возвращает только те строки, которые есть в обеих выборках.

Работает как логическое "и": показывает имена сотрудников, которые одновременно имеют бонус и зарплату выше 60 000.

Удаляет дубликаты и сравнивает строки по значению, не по позиции.

#### 3. EXCEPT — вычитание множеств
SELECT name FROM employees WHERE dept = 'IT'

EXCEPT

SELECT name FROM employees WHERE bonus IS NULL;
#### WHERE dept = 'IT'
Извлекает имена сотрудников из отдела IT.

#### WHERE bonus IS NULL
Находит тех, у кого нет значения в поле bonus.

#### EXCEPT
Возвращает строки, которые есть в первом наборе, но отсутствуют во втором.

В данном случае: всех сотрудников из IT, у которых есть бонус.

Этот оператор также удаляет дубликаты и работает на уровне значений, как UNION.

# PostgrseSQL
Далее будут написаны отличия запроса в PostgrseSQL от SQLite, все что не упомянуто ниже остается таким же как и в SQLite

файлы:

https://github.com/NT-005-TN/SQL-note/blob/main/postgrseSQL_File_1.sql

https://github.com/NT-005-TN/SQL-note/blob/main/postgrseSQL_File_2.sql

#### WITH employees AS (...) — явное указание типа NULL-значений
В PostgreSQL для NULL, особенно в конструкциях с UNION ALL, часто указывают типы, чтобы избежать неоднозначностей:

SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, NULL::int AS bonus

NULL::int — явное указание, что NULL — это целое число (int).

Это важно, чтобы PostgreSQL корректно определил тип столбца в CTE и не выдал ошибку или предупреждение.

#### LIMIT и OFFSET — работают так же, как в SQLite
В PostgreSQL эти конструкции полностью совпадают по смыслу и синтаксису с SQLite.

Можно использовать LIMIT 3 OFFSET 1 без изменений.

#### Типизация и литералы строк
В PostgreSQL строки в SQL-запросах всегда берутся в одинарные кавычки '...'.

Числовые и логические типы строго соблюдаются.

#### Подзапросы и CASE — расширенные возможности
PostgreSQL поддерживает более сложные выражения в CASE, включая вложенные CASE.

В запросе используется стандартный синтаксис — отличий здесь нет.

####  JOIN — поддерживает все типы JOIN (INNER, LEFT, RIGHT, FULL)
В PostgreSQL поддерживаются все виды соединений таблиц, включая RIGHT JOIN и FULL OUTER JOIN.

В примере используются INNER JOIN и LEFT JOIN, которые идентичны SQLite.

#### Работа с NULL — поведение строгое
В PostgreSQL операции с NULL подчиняются стандарту SQL:

NULL не равно ничему, даже самому себе.

Для проверки NULL используется IS NULL и IS NOT NULL.

В коде это используется корректно, никаких изменений не требуется.

####  UNION, INTERSECT, EXCEPT — семантика
Семантика этих операций в PostgreSQL совпадает с SQLite, но в PostgreSQL операции всегда удаляют дубликаты (исключая UNION ALL).

PostgreSQL поддерживает все эти операции и оптимизирован для работы с большими объёмами данных.

####  Пример с типами в CTE (PostgreSQL)
WITH employees AS (

    SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, NULL::int AS bonus UNION ALL
    
    SELECT 2, 'Bob', 'IT', 70000, 5000 UNION ALL
    
    ...
    
)

Явное указание типа NULL помогает избежать ошибок компиляции.

#### Функции агрегации и группировки — расширенные возможности

В PostgreSQL поддерживаются оконные функции, которые можно добавить в запрос, например, ROW_NUMBER() OVER(...).

В запросе это не используется, но при необходимости это легко расширяется.

#### Поддержка подзапросов — полная
Подзапросы в SELECT, WHERE, FROM работают без ограничений.

Подзапросы могут возвращать множество строк или одно значение, поддерживаются коррелированные подзапросы (как в твоём запросе).

#### Псевдонимы и кавычки
Если в PostgreSQL имена столбцов или таблиц содержат заглавные буквы или спецсимволы, их нужно брать в двойные кавычки "ColumnName".

В запросе имена простые и кавычки не нужны.

# OracleSQL
Аналогично прошлой части.

файлы:

https://github.com/NT-005-TN/SQL-note/blob/main/oracleSQL_File_1.sql

https://github.com/NT-005-TN/SQL-note/blob/main/oracleSQL_File_2.sql

#### WITH employees AS (...)
В Oracle SQL:

Для создания строк используется SELECT ... FROM DUAL, так как нельзя писать SELECT ... UNION ALL SELECT ... без указания таблицы.

Таблица DUAL — специальная служебная таблица с одной строкой, используемая для выборок без реальных таблиц.


SELECT 1 AS id, 'Alice' AS name, 'HR' AS dept, 50000 AS salary, CAST(NULL AS NUMBER) AS bonus FROM dual

UNION ALL

SELECT 2, 'Bob', 'IT', 70000, 5000 FROM dual

...

Пояснение:

В Oracle каждая часть SELECT должна иметь источник данных, здесь это dual.

CAST(NULL AS NUMBER) — явное указание типа NULL, чтобы избежать ошибок приведения типов.

#### LIMIT и OFFSET

В Oracle SQL нет ключевых слов LIMIT и OFFSET. Вместо них используется конструкция:


OFFSET 1 ROWS FETCH NEXT 3 ROWS ONLY

OFFSET 1 ROWS — пропустить 1 строку.

FETCH NEXT 3 ROWS ONLY — взять следующие 3 строки.

Пояснение:

Это синтаксис стандарта SQL:2008, который Oracle реализует с версии 12c. Работает аналогично LIMIT ... OFFSET ... в других СУБД.

#### Объявление временных таблиц (CTE) с WITH
В Oracle SQL, при использовании CTE:

Каждый SELECT должен иметь FROM dual.

Все строки объединяются с помощью UNION ALL.

#### Типы данных и CAST
Для NULL в числовых столбцах требуется явное приведение типа: CAST(NULL AS NUMBER).

В SQLite это не нужно, так как там динамическая типизация.

#### EXCEPT → MINUS
Oracle не поддерживает оператор EXCEPT, вместо него используется:
  
SELECT name FROM employees WHERE dept = 'IT'

MINUS

SELECT name FROM employees WHERE bonus IS NULL;
  
Пояснение:

MINUS возвращает строки из первого запроса, которых нет во втором — полностью аналогично EXCEPT в других СУБД.

#### Особенности INNER JOIN, LEFT JOIN
В Oracle INNER JOIN и LEFT JOIN работают так же, как и в SQLite, различий нет.

Отличия могут быть в обработке NULL и оптимизации, но для базовых запросов это не критично.

#### Особенности CASE
CASE в Oracle работает идентично стандарту SQL, никаких отличий по синтаксису и логике нет.

#### LIKE и NOT LIKE
Аналогично другим СУБД: % — любой набор символов, _ — один символ.

В Oracle важен регистр символов (по умолчанию поиск чувствителен к регистру). Чтобы сделать нечувствительным, нужно использовать функции, например, UPPER().

#### Сортировка и фильтрация
ORDER BY ... DESC работает как обычно.

Порядок сортировки важен для корректной работы OFFSET FETCH.

#### Кратко по операциям с множествами в Oracle

UNION ALL -	Совпадает -	Объединяет все строки, включая дубликаты.

INTERSECT -	Совпадает -	Возвращает пересечение, уникальные строки.

EXCEPT - Вместо EXCEPT используется MINUS, возвращает строки из первого запроса, отсутствующие во втором.
